/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.7.0 Sun Feb  6 13:23:56 2022.
 */

#ifndef ODRIVE_CANSIMPLE_H
#define ODRIVE_CANSIMPLE_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define ODRIVE_CANSIMPLE_HEARTBEAT_FRAME_ID (0x01u)
#define ODRIVE_CANSIMPLE_ESTOP_FRAME_ID (0x02u)
#define ODRIVE_CANSIMPLE_GET_MOTOR_ERROR_FRAME_ID (0x03u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ERROR_FRAME_ID (0x04u)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ERROR_FRAME_ID (0x05u)
#define ODRIVE_CANSIMPLE_SET_AXIS_NODE_ID_FRAME_ID (0x06u)
#define ODRIVE_CANSIMPLE_SET_AXIS_STATE_FRAME_ID (0x07u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ESTIMATES_FRAME_ID (0x09u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_COUNT_FRAME_ID (0x0au)
#define ODRIVE_CANSIMPLE_SET_CONTROLLER_MODE_FRAME_ID (0x0bu)
#define ODRIVE_CANSIMPLE_SET_INPUT_POS_FRAME_ID (0x0cu)
#define ODRIVE_CANSIMPLE_SET_INPUT_VEL_FRAME_ID (0x0du)
#define ODRIVE_CANSIMPLE_SET_INPUT_TORQUE_FRAME_ID (0x0eu)
#define ODRIVE_CANSIMPLE_SET_LIMITS_FRAME_ID (0x0fu)
#define ODRIVE_CANSIMPLE_START_ANTICOGGING_FRAME_ID (0x10u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_VEL_LIMIT_FRAME_ID (0x11u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_ACCEL_LIMITS_FRAME_ID (0x12u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_INERTIA_FRAME_ID (0x13u)
#define ODRIVE_CANSIMPLE_GET_IQ_FRAME_ID (0x14u)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ESTIMATES_FRAME_ID (0x15u)
#define ODRIVE_CANSIMPLE_REBOOT_FRAME_ID (0x16u)
#define ODRIVE_CANSIMPLE_GET_VBUS_VOLTAGE_FRAME_ID (0x17u)
#define ODRIVE_CANSIMPLE_CLEAR_ERRORS_FRAME_ID (0x18u)
#define ODRIVE_CANSIMPLE_SET_LINEAR_COUNT_FRAME_ID (0x19u)
#define ODRIVE_CANSIMPLE_SET_POS_GAIN_FRAME_ID (0x1au)
#define ODRIVE_CANSIMPLE_SET_VEL_GAINS_FRAME_ID (0x1bu)

/* Frame lengths in bytes. */
#define ODRIVE_CANSIMPLE_HEARTBEAT_LENGTH (8u)
#define ODRIVE_CANSIMPLE_ESTOP_LENGTH (0u)
#define ODRIVE_CANSIMPLE_GET_MOTOR_ERROR_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ERROR_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ERROR_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_AXIS_NODE_ID_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_AXIS_STATE_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ESTIMATES_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_ENCODER_COUNT_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_CONTROLLER_MODE_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_INPUT_POS_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_INPUT_VEL_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_INPUT_TORQUE_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_LIMITS_LENGTH (8u)
#define ODRIVE_CANSIMPLE_START_ANTICOGGING_LENGTH (0u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_VEL_LIMIT_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_ACCEL_LIMITS_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_TRAJ_INERTIA_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_IQ_LENGTH (8u)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ESTIMATES_LENGTH (8u)
#define ODRIVE_CANSIMPLE_REBOOT_LENGTH (0u)
#define ODRIVE_CANSIMPLE_GET_VBUS_VOLTAGE_LENGTH (8u)
#define ODRIVE_CANSIMPLE_CLEAR_ERRORS_LENGTH (0u)
#define ODRIVE_CANSIMPLE_SET_LINEAR_COUNT_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_POS_GAIN_LENGTH (8u)
#define ODRIVE_CANSIMPLE_SET_VEL_GAINS_LENGTH (8u)

/* Extended or standard frame types. */
#define ODRIVE_CANSIMPLE_HEARTBEAT_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_ESTOP_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_MOTOR_ERROR_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ERROR_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ERROR_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_AXIS_NODE_ID_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_AXIS_STATE_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_ENCODER_ESTIMATES_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_ENCODER_COUNT_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_CONTROLLER_MODE_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_INPUT_POS_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_INPUT_VEL_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_INPUT_TORQUE_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_LIMITS_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_START_ANTICOGGING_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_TRAJ_VEL_LIMIT_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_TRAJ_ACCEL_LIMITS_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_TRAJ_INERTIA_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_IQ_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_SENSORLESS_ESTIMATES_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_REBOOT_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_GET_VBUS_VOLTAGE_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_CLEAR_ERRORS_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_LINEAR_COUNT_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_POS_GAIN_IS_EXTENDED (0)
#define ODRIVE_CANSIMPLE_SET_VEL_GAINS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/**
 * Signals in message Heartbeat.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t axis_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t motor_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_flags;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t controller_flags;
};

/**
 * Signals in message Estop.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_estop_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Get_Motor_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_motor_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t motor_error;
};

/**
 * Signals in message Get_Encoder_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_encoder_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t encoder_error;
};

/**
 * Signals in message Get_Sensorless_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_sensorless_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t sensorless_error;
};

/**
 * Signals in message Set_Axis_Node_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_axis_node_id_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_node_id;
};

/**
 * Signals in message Set_Axis_State.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_axis_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis_requested_state;
};

/**
 * Signals in message Get_Encoder_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_encoder_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_estimate;
};

/**
 * Signals in message Get_Encoder_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_encoder_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t shadow_count;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t count_in_cpr;
};

/**
 * Signals in message Set_Controller_Mode.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_controller_mode_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t control_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t input_mode;
};

/**
 * Signals in message Set_Input_Pos.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_input_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_pos;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t vel_ff;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_ff;
};

/**
 * Signals in message Set_Input_Vel.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_input_vel_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque_ff;
};

/**
 * Signals in message Set_Input_Torque.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_input_torque_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float input_torque;
};

/**
 * Signals in message Set_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float velocity_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float current_limit;
};

/**
 * Signals in message Start_Anticogging.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_start_anticogging_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Set_Traj_Vel_Limit.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_traj_vel_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_vel_limit;
};

/**
 * Signals in message Set_Traj_Accel_Limits.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_traj_accel_limits_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_accel_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_decel_limit;
};

/**
 * Signals in message Set_Traj_Inertia.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_traj_inertia_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float traj_inertia;
};

/**
 * Signals in message Get_Iq.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_iq_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float iq_measured;
};

/**
 * Signals in message Get_Sensorless_Estimates.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_sensorless_estimates_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_pos_estimate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float sensorless_vel_estimate;
};

/**
 * Signals in message Reboot.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_reboot_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Get_Vbus_Voltage.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_get_vbus_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vbus_voltage;
};

/**
 * Signals in message Clear_Errors.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_clear_errors_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Set_Linear_Count.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_linear_count_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t position;
};

/**
 * Signals in message Set_Pos_Gain.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_pos_gain_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pos_gain;
};

/**
 * Signals in message Set_Vel_gains.
 *
 * All signal values are as on the CAN bus.
 */
struct odrive_cansimple_set_vel_gains_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_gain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float vel_integrator_gain;
};

/**
 * Pack message Heartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_heartbeat_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message Heartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_heartbeat_unpack(
    struct odrive_cansimple_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_heartbeat_axis_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_heartbeat_axis_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_heartbeat_axis_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t odrive_cansimple_heartbeat_axis_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_heartbeat_axis_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_heartbeat_axis_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t odrive_cansimple_heartbeat_motor_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_heartbeat_motor_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_heartbeat_motor_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t odrive_cansimple_heartbeat_encoder_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_heartbeat_encoder_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_heartbeat_encoder_flags_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t odrive_cansimple_heartbeat_controller_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_heartbeat_controller_flags_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_heartbeat_controller_flags_is_in_range(uint8_t value);

/**
 * Pack message Estop.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_estop_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_estop_t *src_p,
    size_t size);

/**
 * Unpack message Estop.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_estop_unpack(
    struct odrive_cansimple_estop_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Get_Motor_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_motor_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_motor_error_t *src_p,
    size_t size);

/**
 * Unpack message Get_Motor_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_motor_error_unpack(
    struct odrive_cansimple_get_motor_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_get_motor_error_motor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_motor_error_motor_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_motor_error_motor_error_is_in_range(uint32_t value);

/**
 * Pack message Get_Encoder_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_encoder_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_error_t *src_p,
    size_t size);

/**
 * Unpack message Get_Encoder_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_encoder_error_unpack(
    struct odrive_cansimple_get_encoder_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_get_encoder_error_encoder_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_encoder_error_encoder_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_encoder_error_encoder_error_is_in_range(uint32_t value);

/**
 * Pack message Get_Sensorless_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_sensorless_error_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_sensorless_error_t *src_p,
    size_t size);

/**
 * Unpack message Get_Sensorless_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_sensorless_error_unpack(
    struct odrive_cansimple_get_sensorless_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_get_sensorless_error_sensorless_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_sensorless_error_sensorless_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_sensorless_error_sensorless_error_is_in_range(uint32_t value);

/**
 * Pack message Set_Axis_Node_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_axis_node_id_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_axis_node_id_t *src_p,
    size_t size);

/**
 * Unpack message Set_Axis_Node_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_axis_node_id_unpack(
    struct odrive_cansimple_set_axis_node_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_set_axis_node_id_axis_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_axis_node_id_axis_node_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_axis_node_id_axis_node_id_is_in_range(uint32_t value);

/**
 * Pack message Set_Axis_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_axis_state_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_axis_state_t *src_p,
    size_t size);

/**
 * Unpack message Set_Axis_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_axis_state_unpack(
    struct odrive_cansimple_set_axis_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_set_axis_state_axis_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_axis_state_axis_requested_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_axis_state_axis_requested_state_is_in_range(uint32_t value);

/**
 * Pack message Get_Encoder_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_encoder_estimates_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Get_Encoder_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_encoder_estimates_unpack(
    struct odrive_cansimple_get_encoder_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_encoder_estimates_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_encoder_estimates_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_encoder_estimates_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_encoder_estimates_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_encoder_estimates_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_encoder_estimates_vel_estimate_is_in_range(float value);

/**
 * Pack message Get_Encoder_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_encoder_count_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_encoder_count_t *src_p,
    size_t size);

/**
 * Unpack message Get_Encoder_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_encoder_count_unpack(
    struct odrive_cansimple_get_encoder_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_get_encoder_count_shadow_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_encoder_count_shadow_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_encoder_count_shadow_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_get_encoder_count_count_in_cpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_encoder_count_count_in_cpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_encoder_count_count_in_cpr_is_in_range(uint32_t value);

/**
 * Pack message Set_Controller_Mode.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_controller_mode_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_controller_mode_t *src_p,
    size_t size);

/**
 * Unpack message Set_Controller_Mode.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_controller_mode_unpack(
    struct odrive_cansimple_set_controller_mode_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_set_controller_mode_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_controller_mode_control_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_controller_mode_control_mode_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t odrive_cansimple_set_controller_mode_input_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_controller_mode_input_mode_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_controller_mode_input_mode_is_in_range(uint32_t value);

/**
 * Pack message Set_Input_Pos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_input_pos_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_pos_t *src_p,
    size_t size);

/**
 * Unpack message Set_Input_Pos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_input_pos_unpack(
    struct odrive_cansimple_set_input_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_input_pos_input_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_pos_input_pos_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_pos_input_pos_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t odrive_cansimple_set_input_pos_vel_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_pos_vel_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_pos_vel_ff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t odrive_cansimple_set_input_pos_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_pos_torque_ff_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_pos_torque_ff_is_in_range(int16_t value);

/**
 * Pack message Set_Input_Vel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_input_vel_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_vel_t *src_p,
    size_t size);

/**
 * Unpack message Set_Input_Vel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_input_vel_unpack(
    struct odrive_cansimple_set_input_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_input_vel_input_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_vel_input_vel_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_vel_input_vel_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_input_vel_input_torque_ff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_vel_input_torque_ff_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_vel_input_torque_ff_is_in_range(float value);

/**
 * Pack message Set_Input_Torque.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_input_torque_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_input_torque_t *src_p,
    size_t size);

/**
 * Unpack message Set_Input_Torque.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_input_torque_unpack(
    struct odrive_cansimple_set_input_torque_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_input_torque_input_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_input_torque_input_torque_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_input_torque_input_torque_is_in_range(float value);

/**
 * Pack message Set_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_limits_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_limits_t *src_p,
    size_t size);

/**
 * Unpack message Set_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_limits_unpack(
    struct odrive_cansimple_set_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_limits_velocity_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_limits_velocity_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_limits_velocity_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_limits_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_limits_current_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_limits_current_limit_is_in_range(float value);

/**
 * Pack message Start_Anticogging.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_start_anticogging_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_start_anticogging_t *src_p,
    size_t size);

/**
 * Unpack message Start_Anticogging.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_start_anticogging_unpack(
    struct odrive_cansimple_start_anticogging_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_traj_vel_limit_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_vel_limit_t *src_p,
    size_t size);

/**
 * Unpack message Set_Traj_Vel_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_traj_vel_limit_unpack(
    struct odrive_cansimple_set_traj_vel_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_traj_vel_limit_traj_vel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_traj_vel_limit_traj_vel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_traj_vel_limit_traj_vel_limit_is_in_range(float value);

/**
 * Pack message Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_traj_accel_limits_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_accel_limits_t *src_p,
    size_t size);

/**
 * Unpack message Set_Traj_Accel_Limits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_traj_accel_limits_unpack(
    struct odrive_cansimple_set_traj_accel_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_traj_accel_limits_traj_accel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_traj_accel_limits_traj_accel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_traj_accel_limits_traj_accel_limit_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_traj_accel_limits_traj_decel_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_traj_accel_limits_traj_decel_limit_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_traj_accel_limits_traj_decel_limit_is_in_range(float value);

/**
 * Pack message Set_Traj_Inertia.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_traj_inertia_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_traj_inertia_t *src_p,
    size_t size);

/**
 * Unpack message Set_Traj_Inertia.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_traj_inertia_unpack(
    struct odrive_cansimple_set_traj_inertia_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_traj_inertia_traj_inertia_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_traj_inertia_traj_inertia_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_traj_inertia_traj_inertia_is_in_range(float value);

/**
 * Pack message Get_Iq.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_iq_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_iq_t *src_p,
    size_t size);

/**
 * Unpack message Get_Iq.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_iq_unpack(
    struct odrive_cansimple_get_iq_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_iq_iq_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_iq_iq_setpoint_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_iq_iq_setpoint_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_iq_iq_measured_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_iq_iq_measured_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_iq_iq_measured_is_in_range(float value);

/**
 * Pack message Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_sensorless_estimates_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_sensorless_estimates_t *src_p,
    size_t size);

/**
 * Unpack message Get_Sensorless_Estimates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_sensorless_estimates_unpack(
    struct odrive_cansimple_get_sensorless_estimates_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_sensorless_estimates_sensorless_pos_estimate_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_sensorless_estimates_sensorless_vel_estimate_is_in_range(float value);

/**
 * Pack message Reboot.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_reboot_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_reboot_t *src_p,
    size_t size);

/**
 * Unpack message Reboot.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_reboot_unpack(
    struct odrive_cansimple_reboot_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Get_Vbus_Voltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_get_vbus_voltage_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_get_vbus_voltage_t *src_p,
    size_t size);

/**
 * Unpack message Get_Vbus_Voltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_get_vbus_voltage_unpack(
    struct odrive_cansimple_get_vbus_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_get_vbus_voltage_vbus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_get_vbus_voltage_vbus_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_get_vbus_voltage_vbus_voltage_is_in_range(float value);

/**
 * Pack message Clear_Errors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_clear_errors_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_clear_errors_t *src_p,
    size_t size);

/**
 * Unpack message Clear_Errors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_clear_errors_unpack(
    struct odrive_cansimple_clear_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Set_Linear_Count.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_linear_count_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_linear_count_t *src_p,
    size_t size);

/**
 * Unpack message Set_Linear_Count.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_linear_count_unpack(
    struct odrive_cansimple_set_linear_count_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t odrive_cansimple_set_linear_count_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_linear_count_position_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_linear_count_position_is_in_range(int32_t value);

/**
 * Pack message Set_Pos_Gain.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_pos_gain_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_pos_gain_t *src_p,
    size_t size);

/**
 * Unpack message Set_Pos_Gain.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_pos_gain_unpack(
    struct odrive_cansimple_set_pos_gain_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_pos_gain_pos_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_pos_gain_pos_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_pos_gain_pos_gain_is_in_range(float value);

/**
 * Pack message Set_Vel_gains.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int odrive_cansimple_set_vel_gains_pack(
    uint8_t *dst_p,
    const struct odrive_cansimple_set_vel_gains_t *src_p,
    size_t size);

/**
 * Unpack message Set_Vel_gains.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int odrive_cansimple_set_vel_gains_unpack(
    struct odrive_cansimple_set_vel_gains_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_vel_gains_vel_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_vel_gains_vel_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_vel_gains_vel_gain_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float odrive_cansimple_set_vel_gains_vel_integrator_gain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double odrive_cansimple_set_vel_gains_vel_integrator_gain_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool odrive_cansimple_set_vel_gains_vel_integrator_gain_is_in_range(float value);


#ifdef __cplusplus
}
#endif

#endif
